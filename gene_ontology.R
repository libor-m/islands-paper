# analyze gene ontology in detected islands
# input: tm data frame comes from windows.R and has fst_smooth and fst_boot for 
# required data windows

# will rather use external tool for the intersection with all zf annotations
# get the reduced bed3 list 

win_size <- 1e6
islands <- tm %>% 
  filter(fst_smooth > fst_boot) %>% 
  mutate(zf_start=zf_pos - win_size / 2, zf_end=zf_pos + win_size / 2)

ir <- islands %>% {IRanges(start=.$zf_start, end=.$zf_end)}
gr <- GRanges(seqnames=islands$chrom, ranges=ir)
grr <- reduce(gr)

dfgr <- data.frame(chr=grr %>% seqnames, start=grr %>% start, end=grr %>% end)
write.table(dfgr, file='data/islands.bed', row.names=F, col.names=F, sep="\t", quote=F, eol="\n")

# after filtering with bedtools..
library(rtracklayer)
igenes <- import.bed('data/genes-in-islands.bed')

# mygene database looks incomplete for zfinch
library(mygene)
res <- queryMany()

library(biomaRt)
mart <- useMart("ensembl")
d <- listDatasets(mart)
d[grep("Tae", d$description),]
mart <- useMart("ensembl", "tguttata_gene_ensembl")
listFilters(mart) %>% View
listAttributes(mart) %>% filter(grepl("go", name, ignore.case=T))
               
# test mart
getBM(c("ensembl_gene_id", "ensembl_transcript_id", "go_id", "go_linkage_type", "name_1006"), 
      c("ensembl_transcript_id"), c("ENSTGUT00000002388"), mart)

ensg <- grep("^ENS", igenes$name)
ig_ens <- igenes[ensg]

# mine mart
ig_go <- getBM(c("ensembl_gene_id", "ensembl_transcript_id", "go_id", "go_linkage_type", "name_1006"), 
      c("ensembl_transcript_id"), ig_ens$name, mart)

# check how many annotated genes
length(ig_ens$name)
# 1787
ig_go %>% filter(!is.na(go_id)) %>% .$ensembl_gene_id %>% unique %>% length
# 1625
# looks like only few not annotated genes

write.table(ig_go, file='data/ig_go.tsv', row.names=F, sep="\t", quote=F)

# download zebra finch 'gene universe'
uni_go <- getBM(c("ensembl_gene_id", 
                  "ensembl_transcript_id", 
                  "chromosome_name", 
                  "start_position", 
                  "end_position", 
                  "go_id", 
                  "go_linkage_type"), "", "", mart)

write.table(uni_go, file='data/uni_go.tsv', row.names=F, sep="\t", quote=F)

# do a simple topn list analysis for terms in gene islands
# no good, need contrast against background
ig_go %>%
  group_by(name_1006) %>%
  summarize(n=n_distinct(ensembl_gene_id)) %>%
  arrange(dplyr::desc(n)) %>%
  View

# TODO: calculate also depletion

# no idea how it works..
library(topGO)
# maybe gostats will be better - huge mess;)
library(GOstats)

# use http://www.ebi.ac.uk/QuickGO to browse
# check GO.db, interested in GO:0007292 female gamete generation and all descendants
library(GO.db)
goterms = unlist(Term(GOTERM))
whmf = grep("oocyte", goterms)
whmf = grep("female", goterms)
whmf = grep("spermatogenesis", goterms)

goterms[whmf] %>% View

# TODO:
# other GOs to check in GO tree, find appropriate top GO and visualize:
# female genitalia morphogenesis (chrZ hits)
# hits for meiosis, spermatogenesis, male, femala
# 
# GO:0007140 male meiosis
# GO:0007143 female meiotic division
# GO:0030237 female sex determination
# GO:0030238 male sex determination
# GO:0007292 female gamete generation
# GO:0048232 male gamete generation
# GO:0030539 male genitalia development
# GO:0030540 female genitalia development

# GOBPOFFSPRING looks like the correct hash table to use
# get all offspring terms of female gamete generation
GOsubtree <- function(goid) {
  c(goid, GOBPOFFSPRING[goid] %>% as.list %>% unlist)
}

# get the intersection of island genes and GO descendants of female gamete generation
# add the parent term to the filter
fgg <- GOsubtree("GO:0007292")
fgg_pos <- ig_go %>%
  filter(go_id %in% fgg) %>% 
  left_join(ig_ens %>% {data.frame(ensembl_transcript_id=.$name, chrom=seqnames(.), zf_pos=start(.) + (end(.) - start(.)) / 2 )})

# annotate more types of candidate genes
# requires c(goid = group, ..)
# returns df with subtrees generated by giod, where each row has particular group
# (the group could be transferred more effectively than with join, but whatever)
candidate_GOs <- function(clist) {
  lids <- lapply(names(clist), function(x) data.frame(parent=x, go_id=GOsubtree(x)))
  rbind_all(lids) %>%
    left_join(data.frame(parent=names(clist), group=clist)) %>%
    left_join(as.data.frame(GOTERM) %>% .[,2:4]) %>%
    unique
}

# pick and annotate some candidate 'speciation' GO groups
# differentiate M/F prezygotyc / postzygotic groups?
# cand_goids <- candidate_GOs(c("GO:0007292" = "female", "GO:0046660" = "female", "GO:0007283" = "male"))

# the real list
# GO:0007140 male meiosis
# GO:0007143 female meiotic division
# GO:0030237 female sex determination
# GO:0030238 male sex determination
# GO:0007292 female gamete generation
# GO:0048232 male gamete generation
# GO:0030539 male genitalia development
# GO:0030540 female genitalia development
cand_goids <- candidate_GOs(c(
  "GO:0007140" = "male",
  "GO:0007143" = "female",
  "GO:0030237" = "female",
  "GO:0030238" = "male",
  "GO:0007292" = "female",
  "GO:0048232" = "male",
  "GO:0030539" = "male",
  "GO:0030540" = "female"))

# check the overlap of child terms
cand_goids$go_id %>% unique %>% length
# looks all children are unique

# transform GRanges to data frame
# (only chrom, pos, gene name)
gr2df <- function(gr) gr %>% {data.frame(
  ensembl_transcript_id = .$name, 
  chrom = seqnames(.), 
  zf_pos=(start(.) + end(.)) / 2)}

# pick the genes that fall into the candidate GO subtrees
# this is good to check if there is any potential reason for 
# the high fst
ig_cands <- gr2df(ig_ens) %>% 
  inner_join(ig_go %>% filter(go_id %in% bpids)) %>% 
  inner_join(cand_goids)

#TODO: pick candidates from universe instead of islands
# (download also coordinates from mart to uni_go)
# this is good for what? chromosome enrichment maybe
ig_cands <- uni_go %>% 
  mutate(chrom = paste0("chr", chromosome_name), 
         zf_pos = (start_position + end_position) / 2) %>%
  inner_join(cand_goids)

# plot it all
# - fst smoothed and bootstrap
# - putative islands
# - candidate genes for male and female
tm %>%
  filter(chrom %in% bigchroms) %>%
  ggplot(aes(zf_pos)) + 
  geom_line(aes(y=fst_boot), colour="yellow") +
  geom_line(aes(y=fst_smooth), colour="blue") +  
  geom_point(y=.2, colour="blue", shape=15, size=2, data=tm %>% filter(fst_smooth > fst_boot, chrom %in% bigchroms)) +
  geom_point(aes(y=ifelse(group == "male", -.1, -.05), shape=group), data=ig_cands %>% filter(chrom %in% bigchroms), size=3, colour="red") +
  scale_shape_manual(values=c(1, 2)) +
  facet_wrap(~chrom, ncol=1) +
  ylim(c(-.1, .2)) +
  ggtitle("nightingale speciation islands as mapped to zebra finch chromosomes, 25k bootstrap")

ggsave('results/fst_islands.pdf', width=20, height=16)

# now look at GO/BP of the genes in the highest scoring islands
# tm has the information on smoothed ans bootstrapped fst
# find genes for each island and join the fst values
ig_tree <- GIntervalTree(ig_ens)
gra <- islands %>% {GRanges(seqnames=.$chrom, ranges=ir, fst_smooth=.$fst_smooth, fst_boot=.$fst_boot)}
bpids <- Ontology(GOTERM) %>% 
  {data.frame(term=names(.), onto=.)} %>%
  filter(onto == "BP") %>%
  .$term %>%
  as.character

igenes_ann <- findOverlaps(gra, ig_tree) %>%
  as.data.frame %>%
  mutate(chrom = as.factor(seqnames(ig_tree)[subjectHits]), 
         zf_pos = ig_tree %>% start %>% {.[subjectHits]},
         ensembl_transcript_id = ig_tree$name[subjectHits],
         fst_smooth = gra$fst_smooth[queryHits],
         fst_boot = gra$fst_boot[queryHits],
         fst_diff = fst_smooth - fst_boot) %>%
  left_join(ig_go %>% filter(go_id %in% bpids)) %>%
  filter(!is.na(go_id)) %>%
  unique %>%
  arrange(dplyr::desc(fst_diff))   

# save top 1k gene entries in the most differentiated areas
igenes_ann %>% head(1000) %>% write.table(file="data/fst_diff-top-1k.tsv", sep="\t", quote=F, row.names=F)
igenes_ann %>% filter(chrom == "chrZ") %>% write.table(file="data/fst_diff-chrZ.tsv", sep="\t", quote=F, row.names=F)

# could chromosome 4 contain 'song' cluster?
# TODO: find song genes
igenes_ann %>% filter(chrom == "chr4") %>% View

# plot fst difference for chromosomes
islands %>%
  filter(chrom %in% bigchroms) %>%
  mutate(chromo=chrom %>% factor(levels=chrom %>% levels %>% mixedsort)) %>%
  ggplot(aes(chromo, fst_smooth - fst_boot)) + geom_boxplot()

# just to check we do the filtering right
dbpids <- GOTERM %>%
  as.data.frame %>%
  .[,2:4] %>%
  unique %>%
  arrange(go_id) %>%
  filter(Ontology == "BP")

#
# look where the song related probes are located
#
# name the importatn columns
colnames(blat)[c(10, 14, 16, 17)] <- c("probe", "chrom", "zf_start", "zf_end")

# annotate by the original module annotation
probes <- read.delim("song/song-modules.tsv", header=F) %>%
  dplyr::rename(module=V6) %>%
  dplyr::select(module) %>% 
  mutate(probe=paste0("seq", 1:length(module)))

blat <- read.delim('song/probe-blat-full.psl', skip=5, header=F) %>%
  dplyr::rename(match=V1, mismatch=V2, probe=V10, chrom=V14, zf_start=V16, zf_end=V17) %>%
  filter(match > 58, mismatch < 2) %>%
  mutate(zf_pos = (zf_start + zf_end) / 2) %>%
  inner_join(probes)

irblat <- blat %>% {IRanges(start=.$zf_start, end=.$zf_end)}
grblat <- blat %>% {GRanges(seqnames=.$chrom, ranges=irblat)}
igblat <- findOverlaps(gra, grblat) %>%
  as.data.frame %>%
  mutate(chrom = as.factor(seqnames(grblat)[subjectHits]), 
         zf_pos = blat %>% {.$zf_pos[subjectHits]},
         module = blat %>% {.$module[subjectHits]})
  
# TODO: should split the plot into premade parts not to copy the code around
tm %>%
  filter(chrom %in% bigchroms) %>%
  ggplot(aes(zf_pos)) + 
  geom_line(aes(y=fst_boot), colour="yellow") +
  geom_line(aes(y=fst_smooth), colour="blue") +  
  geom_point(y=.2, colour="blue", shape=15, size=2, data=tm %>% filter(fst_smooth > fst_boot, chrom %in% bigchroms)) +
  geom_point(aes(shape=module), data=blat %>% filter(chrom %in% bigchroms), size=3, colour="red", y=-.1) +
  scale_shape_manual(values=c(1, 2, 3)) +
  facet_wrap(~chrom, ncol=1) +
  ylim(c(-.1, .2)) +
  ggtitle("nightingale speciation islands as mapped to zebra finch chromosomes, 25k bootstrap, song gene probes")

ggsave('results/fst_islands-song.pdf', width=20, height=16)
ggsave('results/fst_islands-song-all-cand.pdf', width=20, height=16)

ggplot(blat, aes(V1)) + geom_histogram()
